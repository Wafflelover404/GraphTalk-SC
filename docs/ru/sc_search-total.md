# sc_search-total.py - Продвинутый рекурсивный поиск по базе знаний

## Обзор
Обеспечивает комплексную, рекурсивную функциональность поиска для баз знаний OSTIS с настраиваемым обходом по глубине. Этот модуль реализует продвинутое исследование графа знаний с отображением отношений.

## Основные функции
- **Рекурсивный обход**: Настраиваемое исследование связей графа знаний по глубине
- **Многонаправленный поиск**: Исследует дочерние, родительские и смежные отношения
- **Структурированные результаты**: Возвращает вложенные структуры словарей, представляющие граф знаний
- **Определение типов элементов**: Различает узлы, ссылки и коннекторы
- **Предотвращение циклов**: Предотвращает бесконечные циклы с помощью отслеживания посещенных узлов

## Основные функции

### `kb_search(search_string, max_depth=2)`
Выполняет комплексный поиск по базе знаний с рекурсивным обходом связей.

#### Параметры
- `search_string` (str): Строка поискового запроса
- `max_depth` (int): Максимальная глубина рекурсивного обхода (по умолчанию: 2)

#### Возвращает
- `list`: Список вложенных словарей со структурой:
```python
[
  {
    "element": {
      "address": "ScAddr_value",
      "type": "Keynode|Link Content|Node|Connector",
      "value": "человекочитаемое_содержимое"
    },
    "connections": {
      "child": [...],    # Исходящие связи
      "parent": [...],   # Входящие связи  
      "adjacent": [...]  # Двунаправленные связи
    }
  }
]
```

### `decode_sc_element(addr: ScAddr)`
Преобразует адреса SC-машины в человекочитаемую информацию с правильным определением типа.

#### Параметры
- `addr` (ScAddr): Адрес SC-машины для декодирования

#### Возвращает
- `dict`: Информация об элементе с адресом, типом и значением

### `traverse_connections(start_addr, max_depth, visited, direction, current_depth=1)`
Рекурсивно обходит связи графа знаний в указанных направлениях.

#### Параметры
- `start_addr` (ScAddr): Адрес начального элемента
- `max_depth` (int): Максимальная глубина обхода
- `visited` (set): Набор посещенных адресов (предотвращение циклов)
- `direction` (str): "child", "parent", или "adjacent"
- `current_depth` (int): Текущая глубина обхода

## Направления поиска

### Дочерние связи (исходящие)
```
Шаблон: start_addr --дуга--> цель
```
Находит элементы, на которые указывает начальный элемент.

### Родительские связи (входящие)
```
Шаблон: источник --дуга--> start_addr
```
Находит элементы, которые указывают на начальный элемент.

### Смежные связи (двунаправленные)
```
Шаблон: start_addr --дуга--> цель ИЛИ источник --дуга--> start_addr
```
Находит все непосредственно связанные элементы независимо от направления.

## Алгоритм выполнения

```
1. Начальный поиск
   ├── Разделить строку поиска на термы
   ├── Использовать search_links_by_contents_substrings()
   └── Удалить дубликаты найденных адресов

2. Для каждого адреса результата
   ├── Декодировать информацию элемента
   ├── Обойти дочерние связи (рекурсивно)
   ├── Обойти родительские связи (рекурсивно)
   ├── Обойти смежные связи (рекурсивно)
   └── Построить вложенную структуру результата

3. Рекурсивный обход
   ├── Проверить ограничение глубины и набор посещенных
   ├── Создать SC-шаблон для направления
   ├── Выполнить поиск по шаблону
   ├── Декодировать найденные элементы
   ├── Рекурсивно обойти более глубокие уровни
   └── Вернуть структурированные связи
```

## Типы элементов

### Ключевые узлы
- Системно-идентифицированные узлы с семантическими идентификаторами
- Пример: `{"type": "Keynode", "value": "ostis_technology"}`

### Содержимое ссылок
- Ссылки, содержащие фактические данные/содержимое
- Пример: `{"type": "Link Content", "value": "Текст документации OSTIS"}`

### Узлы
- Обычные узлы без системных идентификаторов
- Пример: `{"type": "Node", "value": "Node_12345"}`

### Коннекторы
- Соединительные элементы между элементами отношений
- Пример: `{"type": "Connector", "value": "Connector_67890"}`

## Конфигурация

### Настройки подключения
- **URL**: `ws://localhost:8090/ws_json`
- **Максимальная глубина по умолчанию**: 2 уровня
- **Отслеживание посещений**: Предотвращает циклы в обходе графа

### Типы шаблонов
- **VAR_PERM_POS_ARC**: Переменная постоянная положительная дуга
- **VAR_NODE**: Переменный узел для сопоставления шаблонов

## Примеры использования

### Базовый рекурсивный поиск
```python
from sc_search_total import kb_search, print_results

# Подключиться к OSTIS
connect("ws://localhost:8090/ws_json")

# Выполнить глубокий поиск
results = kb_search("технология OSTIS", max_depth=3)

# Вывести структурированные результаты
print_results(results)

# Отключиться
disconnect()
```

### Поиск с пользовательской глубиной
```python
# Поверхностный поиск (глубина 1)
shallow_results = kb_search("ИИ", max_depth=1)

# Глубокий поиск (глубина 4)
deep_results = kb_search("семантические сети", max_depth=4)
```

### Ручной обход связей
```python
from sc_search_total import traverse_connections, decode_sc_element

# Получить детали элемента
element_info = decode_sc_element(some_address)

# Исследовать только дочерние связи
children = traverse_connections(
    some_address, 
    max_depth=2, 
    visited=set(), 
    direction="child"
)
```

## Пример формата вывода

```python
[
  {
    "element": {
      "address": "ScAddr(12345)",
      "type": "Keynode", 
      "value": "ostis_technology"
    },
    "connections": {
      "child": [
        {
          "element": {
            "address": "ScAddr(67890)",
            "type": "Link Content",
            "value": "OSTIS - это технология для создания интеллектуальных систем"
          },
          "depth": 2,
          "connections": [...]
        }
      ],
      "parent": [...],
      "adjacent": [...]
    }
  }
]
```

## Сравнение производительности

| Аспект | sc_search.py | sc_search-total.py |
|--------|--------------|-------------------|
| Скорость | Быстро | Медленнее |
| Использование памяти | Низкое | Высокое |
| Глубина анализа | Поверхностная | Глубокая |
| Структура результатов | Плоская | Вложенная |
| Обнаружение отношений | Ограниченное | Комплексное |

## Соображения производительности

### Контроль глубины
- Ограничивайте `max_depth` для управления производительностью
- Глубина 1-2: Быстро для большинства случаев
- Глубина 3-4: Медленнее, но более полная картина
- Глубина 5+: Может быть очень медленной для больших БЗ

### Управление памятью
- Структуры результатов могут стать очень большими
- Используйте отслеживание посещений для предотвращения бесконечных циклов
- Рассмотрите ограничения на количество результатов

### Стратегии оптимизации
```python
# Ограничить количество начальных результатов
def optimized_search(query, max_results=10, max_depth=2):
    initial_results = kb_search(query, max_depth=1)[:max_results]
    detailed_results = []
    
    for result in initial_results:
        detailed = kb_search(result['element']['value'], max_depth)
        detailed_results.append(detailed)
    
    return detailed_results
```

## Интеграция с API

### Использование в FastAPI
```python
@app.post("/deep_query")
async def deep_query(request: QueryRequest, max_depth: int = 2):
    if max_depth > 4:  # Ограничение безопасности
        max_depth = 4
    
    results = kb_search(request.text, max_depth)
    return APIResponse(status="success", response=results)
```

### Пакетная обработка
```python
def batch_deep_search(queries, max_depth=2):
    """Обработка нескольких запросов с оптимизацией подключения"""
    connect("ws://localhost:8090/ws_json")
    
    try:
        results = {}
        for query in queries:
            results[query] = kb_search(query, max_depth)
        return results
    finally:
        disconnect()
```

## Обработка ошибок

### Проверка глубины
```python
def safe_kb_search(search_string, max_depth=2):
    if max_depth < 1:
        max_depth = 1
    elif max_depth > 10:  # Разумное ограничение
        max_depth = 10
    
    return kb_search(search_string, max_depth)
```

### Обработка больших результатов
```python
def limited_kb_search(search_string, max_depth=2, max_elements=100):
    results = kb_search(search_string, max_depth)
    
    if len(results) > max_elements:
        print(f"Предупреждение: Ограничение результатов до {max_elements}")
        results = results[:max_elements]
    
    return results
```

## Лучшие практики

1. **Управление глубиной**: Начинайте с малой глубины и увеличивайте по необходимости
2. **Мониторинг производительности**: Отслеживайте время выполнения для больших поисков
3. **Ограничения памяти**: Реализуйте ограничения на размер результатов
4. **Кэширование**: Кэшируйте результаты для повторяющихся глубоких поисков
5. **Прогрессивное раскрытие**: Позволяйте пользователям постепенно углубляться в результаты
6. **Фильтрация**: Предоставляйте опции фильтрации для больших наборов результатов
