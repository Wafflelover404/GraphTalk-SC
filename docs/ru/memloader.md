# memloader.py - Загрузчик файлов базы знаний

## Обзор
Обрабатывает загрузку и обработку файлов SCS (Semantic Computer Source) в базы знаний OSTIS. Этот модуль предоставляет возможности пакетной обработки для заполнения базы знаний из файловых систем.

## Основные функции
- **Рекурсивное обнаружение файлов**: Находит все .scs файлы в деревьях каталогов
- **Пакетная обработка**: Эффективно загружает несколько файлов
- **Отчетность об ошибках**: Подробная отчетность о статусе для каждого файла
- **Управление подключением**: Обрабатывает подключения к серверу OSTIS
- **Поддержка UTF-8**: Правильная обработка кодировки для международного контента

## Основная функция

### `load_scs_directory(directory_path)`
Рекурсивно находит и загружает все .scs файлы из указанного каталога в базу знаний OSTIS.

#### Параметры
- `directory_path` (str): Путь к каталогу, содержащему .scs файлы

#### Возвращает
- `str`: Подробный отчет о статусе, включающий:
  - Общее количество найденных файлов
  - Количество успешно загруженных файлов
  - Неудачные файлы с деталями ошибок
  - Общий итог обработки

#### Поток обработки
1. **Настройка подключения**: Подключается к серверу OSTIS по адресу `ws://localhost:8090/ws_json`
2. **Обнаружение файлов**: Рекурсивно ищет `.scs` файлы, используя glob паттерны
3. **Чтение контента**: Читает содержимое файлов с кодировкой UTF-8
4. **Пакетная генерация**: Использует `generate_elements_by_scs()` для эффективной загрузки
5. **Отслеживание статуса**: Мониторит успех/неудачу для каждого файла
6. **Очистка**: Автоматически отключается от сервера

## Детали реализации

### Паттерн обнаружения файлов
```python
scs_files = glob.glob(os.path.join(directory_path, "**/*.scs"), recursive=True)
```
- Использует рекурсивный glob паттерн `**/*.scs`
- Ищет во всех подкаталогах
- Фильтрует только по расширению .scs

### Стратегия пакетной обработки
```python
scs_contents = []
for file_path in scs_files:
    with open(file_path, 'r', encoding='utf-8') as f:
        scs_contents.append(f.read())

results = generate_elements_by_scs(scs_contents)
```

### Уровни обработки ошибок
1. **Ошибки чтения файлов**: Проблемы доступа к отдельным файлам
2. **Ошибки генерации SCS**: Сбои загрузки базы знаний
3. **Ошибки подключения**: Проблемы коммуникации с сервером OSTIS

## Примеры использования

### Базовая загрузка каталога
```python
from memloader import load_scs_directory

# Загрузка всех .scs файлов из каталога базы знаний
status = load_scs_directory("./knowledge_bases/medical_kb/")
print(status)
```

### Пример вывода
```
Всего найдено .scs файлов: 15
Успешно загружено: 12 файл(ов)
Не удалось загрузить: 3 файл(ов)
  ❌ Не удалось загрузить: ./kb/broken_syntax.scs
  ❌ Ошибка чтения ./kb/locked_file.scs: Доступ запрещен
  ❌ Не удалось загрузить: ./kb/invalid_format.scs
```

### Интеграция с загрузкой API
```python
# В api.py endpoint загрузки
@app.post("/upload/kb_zip")
async def upload_knowledge_base(file: UploadFile = File(...)):
    # ... логика извлечения ...
    
    # Загрузка извлеченных файлов
    await run_in_threadpool(load_scs_directory, extract_dir)
    
    return APIResponse(status="success", message="БЗ обработана")
```

### Пользовательская обработка с обработкой ошибок
```python
def safe_kb_loading(directory):
    try:
        result = load_scs_directory(directory)
        
        # Разбор результата для определения степени успеха
        lines = result.split('\\n')
        success_line = [l for l in lines if 'Успешно загружено:' in l][0]
        success_count = int(success_line.split(':')[1].strip().split()[0])
        
        return success_count > 0
    except Exception as e:
        print(f"Загрузка не удалась: {e}")
        return False
```

## Формат отчета о статусе

### Случай успеха
```
Всего найдено .scs файлов: 8
Успешно загружено: 8 файл(ов)
Не удалось загрузить: 0 файл(ов)
```

### Случай смешанных результатов
```
Всего найдено .scs файлов: 10
Не удалось прочитать 2 файл(ов):
  ❌ Ошибка чтения ./kb/corrupted.scs: UnicodeDecodeError
  ❌ Ошибка чтения ./kb/missing.scs: FileNotFoundError
Успешно загружено: 6 файл(ов)
Не удалось загрузить: 2 файл(ов)
  ❌ Не удалось загрузить: ./kb/syntax_error.scs
  ❌ Не удалось загрузить: ./kb/invalid_semantics.scs
```

### Категории ошибок

#### Ошибки чтения файлов
- **Проблемы с правами доступа**: Доступ к файлу запрещен
- **Проблемы с кодировкой**: Файлы не в кодировке UTF-8
- **Отсутствующие файлы**: Разорванные симлинки или перемещенные файлы
- **Проблемы с диском**: Ошибки ввода/вывода при чтении

#### Ошибки генерации SCS
- **Синтаксические ошибки**: Недопустимый синтаксис SCS
- **Семантические ошибки**: Недопустимое представление знаний
- **Ошибки сервера**: Сбои обработки OSTIS
- **Проблемы с памятью**: Проблемы обработки больших файлов

## Обработка структуры каталогов

### Типичная структура каталога БЗ
```
knowledge_base/
├── core/
│   ├── concepts.scs
│   ├── relations.scs
│   └── axioms.scs
├── domain/
│   ├── medical_terms.scs
│   ├── procedures.scs
│   └── diseases.scs
└── instances/
    ├── patients.scs
    └── cases.scs
```

### Порядок обработки
- Файлы обрабатываются в порядке, возвращаемом glob.glob()
- Нет специфических гарантий упорядочивания
- Зависимости между файлами должны быть спроектированы независимо от порядка

## Управление подключением

### Конфигурация сервера OSTIS
- **URL**: `ws://localhost:8090/ws_json`
- **Протокол**: WebSocket JSON
- **Авто-подключение**: Устанавливает подключение автоматически
- **Авто-очистка**: Отключается в блоке finally

### Обработка ошибок подключения
```python
try:
    connect("ws://localhost:8090/ws_json")
    # ... обработка файлов ...
except Exception as e:
    return f"Произошла фатальная ошибка: {str(e)}"
finally:
    disconnect()
```

## Соображения производительности

### Использование памяти
- Все содержимое файлов одновременно загружается в память
- Большие каталоги могут потребовать значительного объема RAM
- Рассмотрите разбиение на части для очень больших баз знаний

### Скорость обработки
- Пакетная обработка более эффективна, чем загрузка отдельных файлов
- Сетевая задержка влияет на производительность
- Скорость файлового ввода/вывода зависит от типа хранилища

### Стратегии оптимизации
```python
# Для больших каталогов рассмотрите разбитую обработку
def chunked_directory_loading(directory, chunk_size=10):
    scs_files = glob.glob(os.path.join(directory, "**/*.scs"), recursive=True)
    
    for i in range(0, len(scs_files), chunk_size):
        chunk = scs_files[i:i + chunk_size]
        # Обработка части...
```

## Точки интеграции

### С загрузкой файлов API
```python
# Интеграция с api.py
extract_dir = os.path.join(KB_BASE_DIR, f"kb_{uuid.uuid4().hex}")
# ... извлечение файлов ...
await run_in_threadpool(load_scs_directory, extract_dir)
```

### С системой управления базой знаний
```python
# Система управления БЗ
def update_knowledge_base(kb_id, new_files_dir):
    status = load_scs_directory(new_files_dir)
    
    # Записать статус в систему управления БЗ
    log_kb_update(kb_id, status)
    
    return parse_success_status(status)
```

### Автономное использование
```python
# Прямое использование из командной строки
if __name__ == "__main__":
    status_string = load_scs_directory("./unpacked_kbs/")
    print(status_string)
```

## Стратегии восстановления после ошибок

### Обработка частичного успеха
```python
def extract_success_count(status_report):
    """Извлечь количество успешно загруженных файлов из отчета о статусе"""
    for line in status_report.split('\\n'):
        if 'Успешно загружено:' in line:
            return int(line.split(':')[1].strip().split()[0])
    return 0

# Использование для сценариев частичного успеха
success_count = extract_success_count(status)
if success_count > 0:
    print(f"Частичный успех: {success_count} файлов загружено")
```

### Механизмы повтора
```python
def robust_directory_loading(directory, max_retries=3):
    for attempt in range(max_retries):
        try:
            result = load_scs_directory(directory)
            if "Фатальная ошибка" not in result:
                return result
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            time.sleep(2 ** attempt)  # Экспоненциальная задержка
```

## Лучшие практики

1. **Валидация каталога**: Убедитесь, что каталог существует перед обработкой
2. **Проверка прав доступа**: Проверьте права на чтение целевого каталога
3. **Согласованность кодировки**: Используйте кодировку UTF-8 для всех .scs файлов
4. **Мониторинг ошибок**: Разбирайте отчеты о статусе для обнаружения ошибок
5. **Управление размером пакета**: Учитывайте ограничения памяти для больших каталогов
6. **Стабильность подключения**: Убедитесь, что сервер OSTIS стабилен перед большими загрузками
7. **Стратегия резервного копирования**: Создайте резервную копию базы знаний перед загрузкой нового контента
8. **Журналирование статуса**: Регистрируйте отчеты о статусе для аудиторских журналов
