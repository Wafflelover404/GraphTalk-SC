# json-llm.py - Генерация JSON структуры из естественного языка

## Обзор
Преобразует текст на естественном языке в структурированный JSON формат, следуя стандарту SC-Machine JSON. Этот модуль обеспечивает семантический разбор текста в машинно-читаемые представления знаний.

## Основные функции
- **Преобразование текста в JSON**: Трансформирует естественный язык в структурированные семантические данные
- **Соответствие стандарту SC-Machine**: Следует формальной спецификации для семантических отношений
- **Разбор на основе LLM**: Использует GPT-4o-mini для интеллектуального анализа текста
- **Валидация JSON**: Обеспечивает соответствие выходных данных валидному JSON формату
- **Атрибуция источника**: Сохраняет исходный текст в выводе для отслеживания

## Основная функция

### `llm_call(message)`
Преобразует сообщения в виде простого текста в структурированный JSON, следуя стандарту SC-Machine JSON.

#### Параметры
- `message` (str): Входной текст для преобразования в JSON структуру

#### Возвращает
- `dict`: Разобранный JSON объект, следующий стандарту SC-Machine, или `None` в случае неудачного разбора

#### Формат JSON структуры
```json
{
  "[Тип связи]": {
    "[Субъектный узел]": "[Объектный узел]",
    "[Субъектный узел]": ["Объектный узел (массив при необходимости)"]
  },
  "membership": {
    "[Узел]": ["Модификатор 1", "Модификатор 2"]
  },
  "Source content": "[Исходный входной текст]"
}
```

## Стандарт SC-Machine JSON

### Типы связей
Семантические отношения, выраженные как глагольные фразы:
- `"Обучаться в"` (обучение в)
- `"Работать в"` (работа в)  
- `"Принадлежать к"` (принадлежность к)

### Принадлежность
Атрибуты и модификаторы для узлов:
- Прилагательные, описывающие сущности
- Классификации и категории
- Свойства и характеристики

### Исходный контент
- Исходный необработанный входной текст
- Обязателен для всех выводов
- Обеспечивает отслеживаемость и проверку

## Детали реализации

### Проектирование промпта
Функция использует сложную структуру промпта:

1. **Базовый промпт**: Загружается из файла `json-prompt.md`
2. **JSON инструкции**: Строгие требования к форматированию
3. **Примерная структура**: Шаблон, показывающий ожидаемый формат вывода
4. **Правила валидации**: Обеспечивает соответствие валидному JSON

### Конфигурация модели
- **Модель**: `gpt-4o-mini` (экономичная, надежная)
- **Провайдер**: клиент g4f (GPT4Free)
- **Веб-поиск**: Отключен (чистая обработка текста)
- **Формат вывода**: Только JSON ответы

## Примеры использования

### Базовое преобразование текста
```python
from json_llm import llm_call

# Преобразование русского текста в JSON
text = "Я обучаюсь в Национальном детском технопарке"
result = llm_call(text)

if result:
    print(json.dumps(result, ensure_ascii=False, indent=2))
```

### Ожидаемый вывод
```json
{
  "Обучаться в": {
    "Я": "технопарк"
  },
  "membership": {
    "технопарк": ["Национальный", "детский"]
  },
  "Source content": "Я обучаюсь в Национальном детском технопарке"
}
```

### Пакетная обработка
```python
texts = [
    "Студент изучает математику в университете",
    "Компания разрабатывает искусственный интеллект",
    "Исследователь работает над новым проектом"
]

results = []
for text in texts:
    json_result = llm_call(text)
    if json_result:
        results.append(json_result)
        
# Сохранить все результаты
with open("batch_output.json", "w", encoding="utf-8") as f:
    json.dump(results, f, ensure_ascii=False, indent=2)
```

### Обработка вывода файлов
```python
# Использование функциональности основного скрипта
if __name__ == "__main__":
    result = llm_call("Я обучаюсь в Национальном детском технопарке")
    if result is not None:
        with open("output.json", "w", encoding="utf-8") as f:
            json.dump(result, f, ensure_ascii=False, indent=2)
        print("JSON записан в output.json")
    else:
        print("Нет валидного JSON для записи.")
```

## Анализ структуры промпта

### Базовый промпт (из json-prompt.md)
- Определяет стандарт SC-Machine JSON
- Предоставляет определения структуры
- Показывает правила валидации
- Включает примеры трансформаций

### Инструкции только JSON
```
"ВАЖНО: Отвечайте ТОЛЬКО валидным JSON объектом, который строго следует стандарту SC-Machine JSON. 
Не включайте никаких объяснений, комментариев или дополнительного текста. JSON должен соответствовать структуре ниже:
{
  "[Тип связи]": {
    "[Субъектный узел]": "[Объектный узел]",
    "[Субъектный узел]": ["Объектный узел (массив при необходимости)"]
  },
  "membership": {
    "[Узел]": ["Модификатор 1", "Модификатор 2"]
  },
  "Source content": "[Исходный входной текст]"
}
Убедитесь, что вывод строго валидный JSON."
```

## Особенности обработки языка

### Нормализация
- Преобразует склоненные формы в именительный падеж
- Извлекает базовые семантические отношения
- Обрабатывает сложные структуры предложений

### Извлечение отношений
- Идентифицирует паттерны субъект-глагол-объект
- Отображает семантические роли на JSON структуру
- Сохраняет семантику отношений

### Группировка атрибутов
- Собирает модификаторы и прилагательные
- Связывает атрибуты с правильными сущностями
- Поддерживает семантическую связность

## Обработка ошибок

### Ошибки разбора JSON
```python
try:
    parsed_json = json.loads(content)
    return parsed_json
except json.JSONDecodeError as e:
    print(f"Ошибка: Ответ LLM не является валидным JSON. Детали ошибки: {e}")
    return None
```

### Валидация ответа LLM
- Проверяет валидный JSON формат
- Проверяет наличие обязательных полей
- Мягко обрабатывает неправильные ответы

### Отладочный вывод
```python
print("Сырой вывод LLM:", repr(content))
```
Обеспечивает отладку ответов LLM для устранения неполадок.

## Паттерны интеграции

### Заполнение базы знаний
```python
# Преобразование текста в структурированные данные для вставки в БЗ
documents = load_text_documents()
structured_data = []

for doc in documents:
    json_structure = llm_call(doc.content)
    if json_structure:
        structured_data.append(json_structure)

# Вставка в базу знаний
insert_into_kb(structured_data)
```

### Конвейер семантического анализа
```python
def analyze_text_semantics(text):
    # 1. Преобразование в JSON структуру
    json_data = llm_call(text)
    
    # 2. Извлечение семантических компонентов
    if json_data:
        connections = extract_connections(json_data)
        memberships = extract_memberships(json_data)
        source = json_data.get("Source content")
        
        return {
            "connections": connections,
            "memberships": memberships,
            "source": source
        }
    return None
```

### Обеспечение качества
```python
def validate_json_output(json_data):
    required_fields = ["Source content"]
    
    # Проверка обязательных полей
    for field in required_fields:
        if field not in json_data:
            return False
    
    # Валидация структуры
    if not isinstance(json_data.get("membership", {}), dict):
        return False
        
    return True
```

## Соображения производительности

### Использование токенов
- Длина входного текста влияет на потребление токенов
- Сложные предложения требуют больше обработки
- Мониторинг затрат API для крупномасштабной обработки

### Качество ответов
- Качество зависит от сложности текста и языка
- Обработка русского языка может иметь вариации
- Рассмотрите валидацию постобработки

### Пакетная обработка
- Обрабатывайте тексты пакетами для эффективности
- Реализуйте логику повторов для неудачных преобразований
- Кэшируйте результаты для повторяющихся текстов

## Лучшие практики

1. **Валидация входных данных**: Убедитесь, что входной текст хорошо сформирован
2. **Проверка вывода**: Всегда проверяйте валидный JSON вывод
3. **Обработка ошибок**: Реализуйте надежную обработку ошибок для производственного использования
4. **Языковая согласованность**: Поддерживайте согласованное использование языка (русский в примерах)
5. **Сохранение источника**: Всегда включайте исходный текст в вывод
6. **Валидация формата**: Проверяйте соответствие стандарту SC-Machine
7. **Оптимизация пакетов**: Используйте пакетную обработку для нескольких текстов
8. **Мониторинг затрат**: Отслеживайте использование API и оптимизируйте для экономичности

## Зависимости файлов

### json-prompt.md
Содержит полную спецификацию стандарта SC-Machine JSON, включая:
- Определения структуры
- Правила валидации
- Примеры трансформаций
- Руководящие принципы обработки крайних случаев

Этот файл критически важен для правильного создания промпта и должен поддерживаться вместе с кодом.
